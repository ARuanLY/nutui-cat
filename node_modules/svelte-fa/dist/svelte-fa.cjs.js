'use strict';

var internal = require('svelte/internal');

/* src\fa.svelte generated by Svelte v3.42.4 */

function add_css(target) {
	internal.append_styles(target, "svelte-1cj2gr0", ".spin.svelte-1cj2gr0{animation:svelte-1cj2gr0-spin 2s 0s infinite linear}.pulse.svelte-1cj2gr0{animation:svelte-1cj2gr0-spin 1s infinite steps(8)}@keyframes svelte-1cj2gr0-spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}");
}

// (143:0) {#if i[4]}
function create_if_block(ctx) {
	let svg;
	let g1;
	let g0;
	let svg_class_value;
	let svg_viewBox_value;

	function select_block_type(ctx, dirty) {
		if (typeof /*i*/ ctx[7][4] == 'string') return create_if_block_1;
		return create_else_block;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			svg = internal.svg_element("svg");
			g1 = internal.svg_element("g");
			g0 = internal.svg_element("g");
			if_block.c();
			internal.attr(g0, "transform", /*transform*/ ctx[10]);
			internal.attr(g1, "transform", "translate(256 256)");
			internal.attr(svg, "id", /*id*/ ctx[0]);
			internal.attr(svg, "class", svg_class_value = "" + (internal.null_to_empty(/*c*/ ctx[9]) + " svelte-1cj2gr0"));
			internal.attr(svg, "style", /*s*/ ctx[8]);
			internal.attr(svg, "viewBox", svg_viewBox_value = `0 0 ${/*i*/ ctx[7][0]} ${/*i*/ ctx[7][1]}`);
			internal.attr(svg, "aria-hidden", "true");
			internal.attr(svg, "role", "img");
			internal.attr(svg, "xmlns", "http://www.w3.org/2000/svg");
		},
		m(target, anchor) {
			internal.insert(target, svg, anchor);
			internal.append(svg, g1);
			internal.append(g1, g0);
			if_block.m(g0, null);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(g0, null);
				}
			}

			if (dirty & /*transform*/ 1024) {
				internal.attr(g0, "transform", /*transform*/ ctx[10]);
			}

			if (dirty & /*id*/ 1) {
				internal.attr(svg, "id", /*id*/ ctx[0]);
			}

			if (dirty & /*c*/ 512 && svg_class_value !== (svg_class_value = "" + (internal.null_to_empty(/*c*/ ctx[9]) + " svelte-1cj2gr0"))) {
				internal.attr(svg, "class", svg_class_value);
			}

			if (dirty & /*s*/ 256) {
				internal.attr(svg, "style", /*s*/ ctx[8]);
			}

			if (dirty & /*i*/ 128 && svg_viewBox_value !== (svg_viewBox_value = `0 0 ${/*i*/ ctx[7][0]} ${/*i*/ ctx[7][1]}`)) {
				internal.attr(svg, "viewBox", svg_viewBox_value);
			}
		},
		d(detaching) {
			if (detaching) internal.detach(svg);
			if_block.d();
		}
	};
}

// (163:8) {:else}
function create_else_block(ctx) {
	let path0;
	let path0_d_value;
	let path0_fill_value;
	let path0_fill_opacity_value;
	let path1;
	let path1_d_value;
	let path1_fill_value;
	let path1_fill_opacity_value;

	return {
		c() {
			path0 = internal.svg_element("path");
			path1 = internal.svg_element("path");
			internal.attr(path0, "d", path0_d_value = /*i*/ ctx[7][4][0]);
			internal.attr(path0, "fill", path0_fill_value = /*secondaryColor*/ ctx[3] || /*color*/ ctx[1] || 'currentColor');

			internal.attr(path0, "fill-opacity", path0_fill_opacity_value = /*swapOpacity*/ ctx[6] != false
			? /*primaryOpacity*/ ctx[4]
			: /*secondaryOpacity*/ ctx[5]);

			internal.attr(path0, "transform", "translate(-256 -256)");
			internal.attr(path1, "d", path1_d_value = /*i*/ ctx[7][4][1]);
			internal.attr(path1, "fill", path1_fill_value = /*primaryColor*/ ctx[2] || /*color*/ ctx[1] || 'currentColor');

			internal.attr(path1, "fill-opacity", path1_fill_opacity_value = /*swapOpacity*/ ctx[6] != false
			? /*secondaryOpacity*/ ctx[5]
			: /*primaryOpacity*/ ctx[4]);

			internal.attr(path1, "transform", "translate(-256 -256)");
		},
		m(target, anchor) {
			internal.insert(target, path0, anchor);
			internal.insert(target, path1, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*i*/ 128 && path0_d_value !== (path0_d_value = /*i*/ ctx[7][4][0])) {
				internal.attr(path0, "d", path0_d_value);
			}

			if (dirty & /*secondaryColor, color*/ 10 && path0_fill_value !== (path0_fill_value = /*secondaryColor*/ ctx[3] || /*color*/ ctx[1] || 'currentColor')) {
				internal.attr(path0, "fill", path0_fill_value);
			}

			if (dirty & /*swapOpacity, primaryOpacity, secondaryOpacity*/ 112 && path0_fill_opacity_value !== (path0_fill_opacity_value = /*swapOpacity*/ ctx[6] != false
			? /*primaryOpacity*/ ctx[4]
			: /*secondaryOpacity*/ ctx[5])) {
				internal.attr(path0, "fill-opacity", path0_fill_opacity_value);
			}

			if (dirty & /*i*/ 128 && path1_d_value !== (path1_d_value = /*i*/ ctx[7][4][1])) {
				internal.attr(path1, "d", path1_d_value);
			}

			if (dirty & /*primaryColor, color*/ 6 && path1_fill_value !== (path1_fill_value = /*primaryColor*/ ctx[2] || /*color*/ ctx[1] || 'currentColor')) {
				internal.attr(path1, "fill", path1_fill_value);
			}

			if (dirty & /*swapOpacity, secondaryOpacity, primaryOpacity*/ 112 && path1_fill_opacity_value !== (path1_fill_opacity_value = /*swapOpacity*/ ctx[6] != false
			? /*secondaryOpacity*/ ctx[5]
			: /*primaryOpacity*/ ctx[4])) {
				internal.attr(path1, "fill-opacity", path1_fill_opacity_value);
			}
		},
		d(detaching) {
			if (detaching) internal.detach(path0);
			if (detaching) internal.detach(path1);
		}
	};
}

// (157:8) {#if typeof i[4] == 'string'}
function create_if_block_1(ctx) {
	let path;
	let path_d_value;
	let path_fill_value;

	return {
		c() {
			path = internal.svg_element("path");
			internal.attr(path, "d", path_d_value = /*i*/ ctx[7][4]);
			internal.attr(path, "fill", path_fill_value = /*color*/ ctx[1] || /*primaryColor*/ ctx[2] || 'currentColor');
			internal.attr(path, "transform", "translate(-256 -256)");
		},
		m(target, anchor) {
			internal.insert(target, path, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*i*/ 128 && path_d_value !== (path_d_value = /*i*/ ctx[7][4])) {
				internal.attr(path, "d", path_d_value);
			}

			if (dirty & /*color, primaryColor*/ 6 && path_fill_value !== (path_fill_value = /*color*/ ctx[1] || /*primaryColor*/ ctx[2] || 'currentColor')) {
				internal.attr(path, "fill", path_fill_value);
			}
		},
		d(detaching) {
			if (detaching) internal.detach(path);
		}
	};
}

function create_fragment(ctx) {
	let if_block_anchor;
	let if_block = /*i*/ ctx[7][4] && create_if_block(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = internal.empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			internal.insert(target, if_block_anchor, anchor);
		},
		p(ctx, [dirty]) {
			if (/*i*/ ctx[7][4]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: internal.noop,
		o: internal.noop,
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) internal.detach(if_block_anchor);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { class: clazz = '' } = $$props;
	let { id = '' } = $$props;
	let { style = '' } = $$props;
	let { icon } = $$props;
	let { size = '' } = $$props;
	let { color = '' } = $$props;
	let { fw = false } = $$props;
	let { pull = '' } = $$props;
	let { scale = 1 } = $$props;
	let { translateX = 0 } = $$props;
	let { translateY = 0 } = $$props;
	let { rotate = '' } = $$props;
	let { flip = false } = $$props;
	let { spin = false } = $$props;
	let { pulse = false } = $$props;
	let { primaryColor = '' } = $$props;
	let { secondaryColor = '' } = $$props;
	let { primaryOpacity = 1 } = $$props;
	let { secondaryOpacity = 0.4 } = $$props;
	let { swapOpacity = false } = $$props;
	let i;
	let s;
	let c;
	let transform;

	$$self.$$set = $$props => {
		if ('class' in $$props) $$invalidate(11, clazz = $$props.class);
		if ('id' in $$props) $$invalidate(0, id = $$props.id);
		if ('style' in $$props) $$invalidate(12, style = $$props.style);
		if ('icon' in $$props) $$invalidate(13, icon = $$props.icon);
		if ('size' in $$props) $$invalidate(14, size = $$props.size);
		if ('color' in $$props) $$invalidate(1, color = $$props.color);
		if ('fw' in $$props) $$invalidate(15, fw = $$props.fw);
		if ('pull' in $$props) $$invalidate(16, pull = $$props.pull);
		if ('scale' in $$props) $$invalidate(17, scale = $$props.scale);
		if ('translateX' in $$props) $$invalidate(18, translateX = $$props.translateX);
		if ('translateY' in $$props) $$invalidate(19, translateY = $$props.translateY);
		if ('rotate' in $$props) $$invalidate(20, rotate = $$props.rotate);
		if ('flip' in $$props) $$invalidate(21, flip = $$props.flip);
		if ('spin' in $$props) $$invalidate(22, spin = $$props.spin);
		if ('pulse' in $$props) $$invalidate(23, pulse = $$props.pulse);
		if ('primaryColor' in $$props) $$invalidate(2, primaryColor = $$props.primaryColor);
		if ('secondaryColor' in $$props) $$invalidate(3, secondaryColor = $$props.secondaryColor);
		if ('primaryOpacity' in $$props) $$invalidate(4, primaryOpacity = $$props.primaryOpacity);
		if ('secondaryOpacity' in $$props) $$invalidate(5, secondaryOpacity = $$props.secondaryOpacity);
		if ('swapOpacity' in $$props) $$invalidate(6, swapOpacity = $$props.swapOpacity);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*icon*/ 8192) {
			$$invalidate(7, i = icon && icon.icon || [0, 0, '', [], '']);
		}

		if ($$self.$$.dirty & /*clazz, spin, pulse*/ 12584960) {
			$$invalidate(9, c = [clazz, spin && 'spin', pulse && 'pulse'].filter(cls => cls).join(''));
		}

		if ($$self.$$.dirty & /*fw, pull, size, style*/ 118784) {
			{
				let float;
				let width;
				const height = '1em';
				let lineHeight;
				let fontSize;
				let textAlign;
				let verticalAlign = '-.125em';
				const overflow = 'visible';

				if (fw) {
					textAlign = 'center';
					width = '1.25em';
				}

				if (pull) {
					float = pull;
				}

				if (size) {
					if (size == 'lg') {
						fontSize = '1.33333em';
						lineHeight = '.75em';
						verticalAlign = '-.225em';
					} else if (size == 'xs') {
						fontSize = '.75em';
					} else if (size == 'sm') {
						fontSize = '.875em';
					} else {
						fontSize = size.replace('x', 'em');
					}
				}

				const styleObj = {
					float,
					width,
					height,
					'line-height': lineHeight,
					'font-size': fontSize,
					'text-align': textAlign,
					'vertical-align': verticalAlign,
					overflow
				};

				let styleStr = '';

				for (const prop in styleObj) {
					if (styleObj[prop]) {
						styleStr += `${prop}:${styleObj[prop]};`;
					}
				}

				$$invalidate(8, s = styleStr + style);
			}
		}

		if ($$self.$$.dirty & /*translateX, translateY, flip, scale, rotate*/ 4063232) {
			{
				const float = parseFloat;
				let t = `translate(${float(translateX) * 512} ${float(translateY) * 512})`;
				let flipX = 1;
				let flipY = 1;

				if (flip) {
					if (flip == 'horizontal') {
						flipX = -1;
					} else if (flip == 'vertical') {
						flipY = -1;
					} else {
						flipX = flipY = -1;
					}
				}

				t += ` scale(${flipX * float(scale)} ${flipY * float(scale)})`;

				if (rotate) {
					t += ` rotate(${rotate} 0 0)`;
				}

				$$invalidate(10, transform = t);
			}
		}
	};

	return [
		id,
		color,
		primaryColor,
		secondaryColor,
		primaryOpacity,
		secondaryOpacity,
		swapOpacity,
		i,
		s,
		c,
		transform,
		clazz,
		style,
		icon,
		size,
		fw,
		pull,
		scale,
		translateX,
		translateY,
		rotate,
		flip,
		spin,
		pulse
	];
}

class Fa extends internal.SvelteComponent {
	constructor(options) {
		super();

		internal.init(
			this,
			options,
			instance,
			create_fragment,
			internal.safe_not_equal,
			{
				class: 11,
				id: 0,
				style: 12,
				icon: 13,
				size: 14,
				color: 1,
				fw: 15,
				pull: 16,
				scale: 17,
				translateX: 18,
				translateY: 19,
				rotate: 20,
				flip: 21,
				spin: 22,
				pulse: 23,
				primaryColor: 2,
				secondaryColor: 3,
				primaryOpacity: 4,
				secondaryOpacity: 5,
				swapOpacity: 6
			},
			add_css
		);
	}
}

module.exports = Fa;
